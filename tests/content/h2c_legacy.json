{
  "magic": "B8n2c@e8kvfx",
  "timestamp": "2020-08-27T19:57:07.639896+00:00",
  "repo": "MikeBishop/http2-certs",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "fc2929"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "enhancement",
      "description": null,
      "color": "84b6eb"
    },
    {
      "name": "help wanted",
      "description": null,
      "color": "159818"
    },
    {
      "name": "invalid",
      "description": null,
      "color": "e6e6e6"
    },
    {
      "name": "question",
      "description": null,
      "color": "cc317c"
    },
    {
      "name": "wontfix",
      "description": null,
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUxNTUzNDUxNTE=",
      "title": "Rename the repo?",
      "url": "https://github.com/MikeBishop/http2-certs/issues/1",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just `http2-certs` perhaps.\n",
      "createdAt": "2016-05-17T19:45:06Z",
      "updatedAt": "2016-05-17T21:02:37Z",
      "closedAt": "2016-05-17T21:02:37Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Didn't know how to do that before.  Done.\n",
          "createdAt": "2016-05-17T21:02:37Z",
          "updatedAt": "2016-05-17T21:02:37Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWUxNTUzNjE4MTA=",
      "title": "Security review:  Repeated signatures of same content",
      "url": "https://github.com/MikeBishop/http2-certs/issues/2",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently, we do a single TLS export for the session, then sign it repeatedly with every key used by either peer.  Brian S. raises the question of whether it would be better to incorporate the Cert-ID into the exported value so that each signature is of a unique value.\n\nI'm not aware that this is necessary, but I'd like to be officially told that by someone whose job is crypto.  If it's needed, it's easy enough to add.\n",
      "createdAt": "2016-05-17T21:05:57Z",
      "updatedAt": "2017-10-30T17:55:56Z",
      "closedAt": "2017-10-30T17:55:56Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "An easy addition would be to sign the request, or just the identifier for the request in addition to the exporter value.  Alternatively, you could feed the same information to the exporter so that you are signing something else.\n",
          "createdAt": "2016-05-18T12:59:57Z",
          "updatedAt": "2016-05-18T14:47:56Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "The certificate_request_context is defined by the application, it can be made unique per request to protect against this. My suggestion is to use the Request-ID as the certificate_request_context. A nonce could also be appended to the Request-ID.",
          "createdAt": "2017-10-24T02:54:38Z",
          "updatedAt": "2017-10-24T02:54:38Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "In e-mail, we agreed on Cert-ID, and the draft prohibits sending multiple things under the same Cert-ID.  I think this is now addressed.",
          "createdAt": "2017-10-30T17:55:56Z",
          "updatedAt": "2017-10-30T17:55:56Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUxNTUzNjQwNDA=",
      "title": "Wasted bits:  HashAndSignatureAlgorithm",
      "url": "https://github.com/MikeBishop/http2-certs/issues/3",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "HashAndSignatureAlgorithm is a sixteen-bit value, but allowed values are currently limited to sixteen (i.e. 4 bits).  Keep the current length so we can reuse TLS-defined values, or shave?  Even if we need to overflow into additional SETTINGS values someday, eight bits seems more than sufficient.\n",
      "createdAt": "2016-05-17T21:16:59Z",
      "updatedAt": "2017-10-30T17:56:31Z",
      "closedAt": "2017-10-30T17:56:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that this level of waste is worth worrying about.\n",
          "createdAt": "2016-05-18T13:00:23Z",
          "updatedAt": "2016-05-18T13:00:23Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Moot (for now, until we fix #12).",
          "createdAt": "2017-10-30T17:56:30Z",
          "updatedAt": "2017-10-30T17:56:30Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUxNTU1MjEzNDk=",
      "title": "Cross-protocol interaction",
      "url": "https://github.com/MikeBishop/http2-certs/issues/4",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This usage creates another context in which the same key is used for signing in two different contexts.  We need to be careful to a) make sure that those signatures can't be transplanted elsewhere, and b) document that we have done so.\n",
      "createdAt": "2016-05-18T14:49:30Z",
      "updatedAt": "2017-10-30T17:03:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "The signature covers the context string \"Exported Authenticator\" (which is not NULL-terminated). I'll add that text to the security considerations.",
          "createdAt": "2017-10-30T17:03:48Z",
          "updatedAt": "2017-10-30T17:03:48Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWUxNTU3OTAwMjA=",
      "title": "Can we get rid of bitmaps?",
      "url": "https://github.com/MikeBishop/http2-certs/issues/5",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Personal opinion, plus Andrei's feedback:\n\nI really dislike the bitmap approach -- I'd much rather use the TLS IANA codepoints that exist.  It's more extensible, better layered (can just relay uninterpreted data to the crypto components)\n- Can we just get this information from the TLS stack?\n- Do we need a TLV-style equivalent to the SETTINGS frame?\n- Get rid of unsolicited certs and put this back in REQUEST?\n\nThis would simplify the SETTINGS value and reconcile it with the algorithm field on the PROOF.\n",
      "createdAt": "2016-05-19T17:18:50Z",
      "updatedAt": "2017-10-23T06:03:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "The unsolicited certs is the feature that really pushed this in this direction.  Those seem to be useful, particularly when it comes to latency.\n",
          "createdAt": "2016-05-19T20:48:49Z",
          "updatedAt": "2016-05-19T20:48:49Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I'm almost wondering whether there's value in, say, an EXTENDED_SETTINGS extension that provides TLV settings values.  The more I try to create extensions in HTTP/2, the more I feel like the fixed 32-bit values are a mite constrained for communicating anything useful.  I don't want to build it in this doc (enough frames already!), but a normative reference might simplify the machinery here. If we could just send an array, then use the same codepoints TLS does, we become much more future-proof and can make the negotiation and PROOF frames match.  Not as compact, but still....\n",
          "createdAt": "2016-05-19T21:19:00Z",
          "updatedAt": "2016-05-19T21:19:00Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to prefer the EXTENDED_SETTINGS option, it allows the reuse of the TLS IANA registries and should require less maintenance when useful new TLS 1.3 extensions are inevitably introduced. \n",
          "createdAt": "2016-06-25T10:28:55Z",
          "updatedAt": "2016-06-25T10:28:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that we sorted this one out with the split.",
          "createdAt": "2017-10-23T06:03:32Z",
          "updatedAt": "2017-10-23T06:03:32Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUxNTU3OTAzMzM=",
      "title": "RSA-PSS versus RSA-PSS",
      "url": "https://github.com/MikeBishop/http2-certs/issues/6",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Andrei:\n\n> nearly all available certs today use RSA-PKCS1.5 rather than RSA-PSS. Are you relying on all sites and clients getting new certs to support this?\n\nThe bitmap is about the signatures which we support in the PROOF frame, not about how the certificates themselves are signed.  Now, whether existing RSA certs can generate RSA-PSS signatures is a question for Crypto folks \u2013 I would think that an RSA key can be used for multiple signing schemes, but I could also be wrong.  Issue to track confirming.\n",
      "createdAt": "2016-05-19T17:20:28Z",
      "updatedAt": "2016-05-20T17:19:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "For TLS, we decided to allow PKCS#1.5.  That was reluctant.  Here, we can limit the choice safely, I think.  Those people that have to spend extra cycles, or who can't do PSS can fall back to less optimized paths (i.e., multiple connections).\n",
          "createdAt": "2016-05-19T20:47:38Z",
          "updatedAt": "2016-05-19T20:47:38Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I agree on the safety of the constraint.  Where I'm out of my depth is whether PSS needs a different _cert_ or just a different signature algorithm with the same cert.\n",
          "createdAt": "2016-05-19T21:20:33Z",
          "updatedAt": "2016-05-19T21:20:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "So there is a different OID for the two algorithms, but ultimately it's just an RSA key, so it can be used with either if you are willing to do so.  I believe that this is the intent with PSS in TLS 1.3.\n",
          "createdAt": "2016-05-20T17:19:24Z",
          "updatedAt": "2016-05-20T17:19:24Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUxNTU3OTA2ODc=",
      "title": "Specific to certificates?",
      "url": "https://github.com/MikeBishop/http2-certs/issues/7",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Andrei:\n\n> all frame names etc. are very cert-specific. You may want to rename them \u201cauthenticators\u201d or similar, and include auth type fields to accommodate e.g. raw keys or PSK. Or you could say non-certificate auth would have to use new frame types defined in a new spec.\n\nI was initially uncertain that there was a use-case for proving multiple raw keys (since what we\u2019re ultimately trying to prove with certs is a strong name binding), but coupled with DANE records as supporting data, I think you could get a name binding off a raw key as well.  Browsers probably won\u2019t support it, but that doesn\u2019t mean the protocol couldn\u2019t allow the flexibility to do it for IoT.\n",
      "createdAt": "2016-05-19T17:22:11Z",
      "updatedAt": "2017-10-23T06:04:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh, DANE.  We run the risk of being overly generic here.  Let's just assume that it's a certificate and then do what TLS does and pack non-certificate things into certificates if it comes to that.\n",
          "createdAt": "2016-05-19T20:46:13Z",
          "updatedAt": "2016-05-19T20:46:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in the split.",
          "createdAt": "2017-10-23T06:04:01Z",
          "updatedAt": "2017-10-23T06:04:01Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUxNTU3OTEwNTg=",
      "title": "Matching rules for subjectAltName",
      "url": "https://github.com/MikeBishop/http2-certs/issues/8",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Andrei:\n\n> if you require support for this OID [subjectAltName] in the CERTIFICATE_REQUEST, then you have to define matching rules (see https://tools.ietf.org/html/draft-ietf-tls-tls13-12#section-6.3.3.2 for an example).\n\nI would have thought they were already defined somewhere, but if not\u2026.\n",
      "createdAt": "2016-05-19T17:24:09Z",
      "updatedAt": "2016-05-19T20:45:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 6125\n",
          "createdAt": "2016-05-19T20:45:05Z",
          "updatedAt": "2016-05-19T20:45:05Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUxNTU3OTE0MDA=",
      "title": "Do you ever include root certs?",
      "url": "https://github.com/MikeBishop/http2-certs/issues/9",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Andrei:\n\n> {#http-certificate}: \u201cA certificate which specifies a trust anchor MAY be omitted\u201d \u2013 why would one ever want to send the root? The peer can\u2019t use it in any way, and in TLS, it\u2019s been a source of interop issues.\n\nSHOULD?  MUST?  Though, back to DANE, if DNS says that the cert must chain to a CA that the client doesn\u2019t otherwise trust, wouldn\u2019t the client need to see that cert to validate the signature?\n\nI defer to my TLS brethren on this issue.\n",
      "createdAt": "2016-05-19T17:25:52Z",
      "updatedAt": "2016-05-19T20:44:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "This is, I think, a complete copy of the TLS language:\n\n> Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.\n\nThe point being that what comprises a \"root\" can be vague.  For example, certification paths can include multiple potential trust anchors.\n",
          "createdAt": "2016-05-19T20:44:50Z",
          "updatedAt": "2016-05-19T20:44:50Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUxNTU4NTA2ODc=",
      "title": "Memory and forgetting",
      "url": "https://github.com/MikeBishop/http2-certs/issues/10",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Requiring the peer to cache everything you send for the lifetime of the connection invites DoS attacks on memory consumption with giant/numerous (possibly fake) certs.  There should be a way to signal that a certificate/request has been discarded; senders would need to re-send if they want to use in the future.\n",
      "createdAt": "2016-05-19T22:35:15Z",
      "updatedAt": "2017-05-24T01:20:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that a simple CERTIFICATE_REQUEST is the way that we do this.",
          "createdAt": "2017-05-24T01:20:04Z",
          "updatedAt": "2017-05-24T01:20:04Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUxODkwMTIxODg=",
      "title": "Add support for communicating the supported signature algorithms in the certificate request",
      "url": "https://github.com/MikeBishop/http2-certs/issues/12",
      "state": "OPEN",
      "author": "grittygrease",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am adding the requirement to expose a new API to TLS libraries in the exported authenticators draft that returns the signature algorithms that the library is willing to validate. This should be incorporated into the CERTIFICATE_REQUEST frame to help the other side choose a certificate that can be validated.",
      "createdAt": "2016-11-14T01:43:54Z",
      "updatedAt": "2016-11-14T01:43:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUyNDUwMTE2MzU=",
      "title": "relation to HTTP-Signature",
      "url": "https://github.com/MikeBishop/http2-certs/issues/14",
      "state": "OPEN",
      "author": "bblfish",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi, there is a specification [Signinging HTTP messages](https://datatracker.ietf.org/doc/draft-cavage-http-signatures/) that can be used for authentication and that is very lightweight - I think it can be implemented nicely in a week - and that does not require any changes to TLS as it is now. This makes it very useful at least for dealing with the current transition where your spec is not finished, (and so browsers have not implemented it) keygen has been removed from most browsers with no replacement in sight that I know of, and TLS does not play nicely with HTTP/2.0 as your spec so very clearly explains. (Thanks for bringing so much clarity to this space!)  \r\n\r\nI have used HTTP-Signature in JS apps to authenticate an app to various servers, and am also implementing a [standalone library for clients and servers](https://github.com/read-write-web/akka-http-signature) for it too. That is clearly within my skill and time level, whereas implementing things at the TLS layer, would require a lot more effort and knowledge on my part.\r\n\r\nI [asked the question on their github repository](https://github.com/w3c-dvcg/http-signatures/issues/10) and I ask it here, as to how the two specs complement each other, and what additional security this one brings. I ask so that I can understand the limitations of using only HTTP-Signatures, and to then also explain to people how both will be able to work together, and why people should support this work too - even though it is further off. Ie what are the limitations of the HTTP-Signatures method of authentication that I need to make people aware of, with the hope that this spec will fix that - understanding of course that no security technology is perfect, and so that all come with limitations.\r\n\r\n\r\n\r\n\r\n\r\n  ",
      "createdAt": "2017-07-24T08:49:57Z",
      "updatedAt": "2017-07-24T16:55:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "Without having closely examined the draft, I'd say the biggest difference is authentication of the channel.  There's a difference between proving that the author of a message is X and proving that the person you're talking to is X.  A signed message could be relayed or replayed at will.\r\n\r\nThis method gives you the converse -- you know who's sending you the message, but you don't actually have proof that they're the original author of what they're sending you.  However, that *seems* less important, unless you're in a situation where you're expecting a third-party to relay and you want to authenticate both the relay and the original source.",
          "createdAt": "2017-07-24T16:55:42Z",
          "updatedAt": "2017-07-24T16:55:42Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUyNjk4MjIxNjY=",
      "title": "Matching CERTIFICATE_NEEDED to USE_CERTIFICATE",
      "url": "https://github.com/MikeBishop/http2-certs/issues/16",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now we don't have an explicit correlation between this and the CERTIFICATE_NEEDED frame, which I think is OK, but it means that a server has to process USE_CERTIFICATE with no expectation of it actually addressing its requirements as expressed.  Basically, it has to decide to authorize the request or not on the merits of what it has.  \r\n\r\nThat potentially leads to a race: client thinks certificate X is what this request needs, so it sends USE_CERTIFICATE(X) after the HEADERS.  Server receives the request, decides that it wants a certificate, so it sends CERTIFICATE_NEEDED and CERTIFICATE_REQUEST as soon as it processes HEADERS.  Then, when the server receives the USE_CERTIFICATE(X), it decides to reject the request.  The client sees the CERTIFICATE_NEEDED/CERTIFICATE_REQUEST, answers the request with CERTIFICATE(Y)/USE_CERTIFICATE(Y), but then finds the next thing it receives is a 4xx status code.\r\n\r\nIt is possible to trace the USE_CERTIFICATE(X) back to the CERTIFICATE and any CERTIFICATE_REQUEST that was made to discover that this isn't in fact a response to the CERTIFICATE_NEEDED that the server made, but it's a pretty long path to follow.  Should we describe that case?",
      "createdAt": "2017-10-31T03:24:20Z",
      "updatedAt": "2017-10-31T03:24:20Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE3MTAxMzE=",
      "title": "Incorporate draft-sullivan-tls-exported-authenticator-00",
      "url": "https://github.com/MikeBishop/http2-certs/pull/11",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change provides a huge simplification of the draft, moving\r\nthe certificate choice and cryptographic operations into the\r\nTLS stack via the Exported Authenticator draft. Many things\r\ndeleted, few things added.",
      "createdAt": "2016-10-31T23:30:18Z",
      "updatedAt": "2016-10-31T23:36:06Z",
      "closedAt": "2016-10-31T23:36:06Z",
      "mergedAt": "2016-10-31T23:36:06Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NTU5Ng==",
          "commit": {
            "abbreviatedOid": "6d51a6d"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Loses cert size issue, I suspect, but that's something we can probably work around later.\n",
          "createdAt": "2016-10-31T23:35:57Z",
          "updatedAt": "2016-10-31T23:35:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyMTI3MDMx",
      "title": "Bah, readme bug",
      "url": "https://github.com/MikeBishop/http2-certs/pull/13",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-05-24T01:19:03Z",
      "updatedAt": "2017-11-11T20:48:00Z",
      "closedAt": "2017-11-11T20:47:56Z",
      "mergedAt": "2017-11-11T20:47:56Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI5MTEyMjE=",
          "commit": {
            "abbreviatedOid": "5fb8fe9"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-10-30T17:04:09Z",
          "updatedAt": "2017-10-30T17:04:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ4MDQ5NDQ0",
      "title": "Redefine CERTIFICATE_REQUEST to lean on TLS harder",
      "url": "https://github.com/MikeBishop/http2-certs/pull/15",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This takes the block we had and says \"take the extensions from a TLS CertificateRequest\" instead.  The nice trick here is that we can use SNI from the client side rather than leaning on the OID thing, which was always a long-shot.",
      "createdAt": "2017-10-23T06:35:53Z",
      "updatedAt": "2017-11-11T20:50:35Z",
      "closedAt": "2017-11-11T20:50:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2017-10-24T03:10:41Z",
          "updatedAt": "2017-10-24T03:10:41Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "body": "I missed that you had an open PR for these changes -- sorry.  I think in the meantime, I've made equivalent changes because you suggested them in e-mail.",
          "createdAt": "2017-11-11T20:50:34Z",
          "updatedAt": "2017-11-11T20:50:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUyNzMwOTQz",
      "title": "Remove AUTOMATIC_USE",
      "url": "https://github.com/MikeBishop/http2-certs/pull/17",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Implementing Kazuho's suggestion to remove AUTOMATIC_USE and replace it with the ability to send USE_CERTIFICATE as part of the request.",
      "createdAt": "2017-11-15T10:03:09Z",
      "updatedAt": "2018-05-14T23:42:43Z",
      "closedAt": "2018-05-14T23:42:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3Mzk3ODA=",
          "commit": {
            "abbreviatedOid": "69ec547"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good. The removal of AUTOMATIC_USE simplifies the server cert case too.",
          "createdAt": "2017-11-15T10:40:03Z",
          "updatedAt": "2017-11-15T10:40:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY5NzQ2MDA=",
          "commit": {
            "abbreviatedOid": "42a9ae2"
          },
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is essentially fine, but I think that we need to take a good hard look at the stream state machine and USE_CERTIFICATE.",
          "createdAt": "2017-11-16T00:12:18Z",
          "updatedAt": "2017-11-16T00:34:21Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I think that we should provide an explicit indication that a certificate will not be provided.  Certificate authentication is often something that you can't put a timer around.  User prompts are involved, which can take an indeterminate time to resolve.  That means that servers in particular will get stuck if the client intends to not provide a response.  An explicit indication that the certificate won't be forthcoming would be good.  TLS does that by including an empty Certificate message.",
              "createdAt": "2017-11-16T00:12:18Z",
              "updatedAt": "2017-11-16T00:34:21Z"
            },
            {
              "originalPosition": 143,
              "body": "This isn't going to map to QUIC well.  And even in h2, the promised stream can't really be used out of the \"reserved\" state.  That's less clear though.  I think that reset is the best plan here given the range of options available (or at least the ones that I have thought about).",
              "createdAt": "2017-11-16T00:20:32Z",
              "updatedAt": "2017-11-16T00:34:21Z"
            },
            {
              "originalPosition": 220,
              "body": "Hmm, I just now realized that we are requiring that USE_CERTIFICATE be sent on a stream that is half-closed on the request side.  In fact, this would suggest that this is mandated.  That's going to be problematic in QUIC, where we don't have the option to send anything.",
              "createdAt": "2017-11-16T00:33:07Z",
              "updatedAt": "2017-11-16T00:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzcwMTg1NTg=",
          "commit": {
            "abbreviatedOid": "42a9ae2"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-16T06:21:12Z",
          "updatedAt": "2017-11-16T06:21:12Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "I think that we should require the client to send the USE_CERTIFICATE frame before the DATA frames that convey the request body.\r\n\r\nThis is because we need a way to cap the amount of the memory being required to buffer the request. In CGI and other gateway protocols, the properties of the client certificate needs to sent before the POST body.\r\n\r\nBy requiring the client to send USE_CERTIFICATE before DATA frames, the upper limit of the buffer size becomes the size of the stream-level flow control window.\r\n\r\nI also think that it would also be a good idea to require the client to _always_ send the USE_CERTIFICATE frame within the request. A server will be permitted to send a CERTIFICATE_NEEDED frame if the client sends an empty USE_CERTIFICATE frame along the HTTP request. The reason I think we should change as such is, because from server's perspective, it is easier to always wait for USE_CERTIFICATE frame rather than figuring out if the frame has been omitted. ",
              "createdAt": "2017-11-16T06:21:12Z",
              "updatedAt": "2017-11-16T06:21:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzcwMTg3Nzk=",
          "commit": {
            "abbreviatedOid": "42a9ae2"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-16T06:22:53Z",
          "updatedAt": "2017-11-16T06:22:53Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "On a TLS connection established using a mutual handshake, we need a way to determine if a client certificate sent as part of the TLS handshake is associated to the HTTP request, or if _no_ certificate is associated. The latter could happen for example when the mutual handshake was negotiated for SNI example.com, and then the client sends a request for example.org using the same connection.\r\n\r\nFor the purpose, it might be a good idea to reserve Cert-ID=0 as a way to indicate the certificate exchanged in the TLS handshake.",
              "createdAt": "2017-11-16T06:22:53Z",
              "updatedAt": "2017-11-16T06:22:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzcwMjI2MDg=",
          "commit": {
            "abbreviatedOid": "42a9ae2"
          },
          "author": "kazuho",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-16T06:54:19Z",
          "updatedAt": "2017-11-16T06:54:19Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "Do we need an error code that indicates the peer to provide a new certificate on a new connection?\r\n\r\nMy understanding is that the draft expects an endpoint to remember all the certificate that the peer has sent in the past. I wonder how the number of the certificate can be capped, and/or, how an endpoint should notify the peer that it has reached the limit.",
              "createdAt": "2017-11-16T06:54:19Z",
              "updatedAt": "2017-11-16T06:54:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUyNzQzNDg5",
      "title": "Incorporate exported authenticator requests",
      "url": "https://github.com/MikeBishop/http2-certs/pull/18",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Tracking changes from https://github.com/tlswg/tls-exported-authenticator/pull/9/ to create an exported authenticator request message at the TLS layer as well.",
      "createdAt": "2017-11-15T10:58:48Z",
      "updatedAt": "2018-05-14T23:43:00Z",
      "closedAt": "2018-05-14T23:43:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NDU1MzU=",
          "commit": {
            "abbreviatedOid": "ab6605e"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T11:02:11Z",
          "updatedAt": "2017-11-15T11:09:07Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "When processed by a client that did not receive it in response to a CERTIFICATE_REQUEST?",
              "createdAt": "2017-11-15T11:02:11Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            },
            {
              "originalPosition": 98,
              "body": "I think you can simply say that you can validate a spontaneous server-generated CERTIFICATE without using the \"get context\" api.",
              "createdAt": "2017-11-15T11:03:51Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            },
            {
              "originalPosition": 65,
              "body": "Is the Cert-ID available at the time of the generation of the CERTIFICATE_REQUEST?",
              "createdAt": "2017-11-15T11:08:51Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NDg1NjM=",
          "commit": {
            "abbreviatedOid": "ab6605e"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Thanks, Nick.  I'll incorporate this shortly.",
          "createdAt": "2017-11-15T11:14:54Z",
          "updatedAt": "2017-11-15T11:22:23Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "You're right -- it should be the Request-ID.",
              "createdAt": "2017-11-15T11:14:54Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            },
            {
              "originalPosition": 96,
              "body": "My intent was to say that \"absent\" is only allowed for clients; for either side, matching one that was previously sent is okay.  Not absent and not a previously-sent request is an invalid combination regardless.\r\n\r\nSuggestions on better wording of that?  I don't feel like the above is any clearer that what's already written.",
              "createdAt": "2017-11-15T11:17:01Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            },
            {
              "originalPosition": 98,
              "body": "I'm not certain it's always possible to tell whether the CERTIFICATE frame is spontaneous or not.  It's obvious if you don't have an outstanding request, but it's also possible to get a spontaneous certificate after sending a request, and you won't know that until you check the request context in the authenticator.\r\n\r\nAlways checking the request context should work in all situations, so it seems like we should just do that rather than having more conditionals.  Welcome to convince me otherwise.  ;-)",
              "createdAt": "2017-11-15T11:22:03Z",
              "updatedAt": "2017-11-15T11:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NTIzNDY=",
          "commit": {
            "abbreviatedOid": "ab6605e"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T11:30:29Z",
          "updatedAt": "2017-11-15T11:30:29Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "This works, it's just that the \"regard to the generated request\" is dependent on the result of whether or not a matching CERTIFICATE_REQUEST was found or not. Maybe updating the text to say \"regard to the generated request, if a matching request was found\"",
              "createdAt": "2017-11-15T11:30:29Z",
              "updatedAt": "2017-11-15T11:30:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NTIzNzU=",
          "commit": {
            "abbreviatedOid": "ab6605e"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T11:30:35Z",
          "updatedAt": "2017-11-15T11:30:35Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I can't think of a better wording. This should be fine.",
              "createdAt": "2017-11-15T11:30:35Z",
              "updatedAt": "2017-11-15T11:30:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NTQ3NDc=",
          "commit": {
            "abbreviatedOid": "ab6605e"
          },
          "author": "MikeBishop",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T11:40:35Z",
          "updatedAt": "2017-11-15T11:40:35Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Already done.  The commit from a few minutes ago adds \"(if any)\".",
              "createdAt": "2017-11-15T11:40:35Z",
              "updatedAt": "2017-11-15T11:40:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3NTQ5OTI=",
          "commit": {
            "abbreviatedOid": "b1d1396"
          },
          "author": "grittygrease",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-11-15T11:41:36Z",
          "updatedAt": "2017-11-15T11:41:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY5Nzk2MDY=",
          "commit": {
            "abbreviatedOid": "b1d1396"
          },
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-16T00:43:27Z",
          "updatedAt": "2017-11-16T00:43:44Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Does this ID replicate the context that is inside the request?",
              "createdAt": "2017-11-16T00:43:27Z",
              "updatedAt": "2017-11-16T00:43:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY5ODIzMjU=",
          "commit": {
            "abbreviatedOid": "b1d1396"
          },
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-16T01:01:20Z",
          "updatedAt": "2017-11-16T01:01:20Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Also, it seems like this is in violation of the recommendation in TLS for unpredictable contexts.",
              "createdAt": "2017-11-16T01:01:20Z",
              "updatedAt": "2017-11-16T01:01:20Z"
            }
          ]
        }
      ]
    }
  ]
}